%!TEX root = std.tex
\rSec0[intro]{General}

\indextext{diagnostic message|see{message, diagnostic}}%
\indexdefn{conditionally-supported behavior|see{behavior, conditionally-supported}}%
\indextext{dynamic type|see{type, dynamic}}%
\indextext{static type|see{type, static}}%
\indextext{ill-formed program|see{program, ill-formed}}%
\indextext{well-formed program|see{program, well-formed}}%
\indextext{implementation-defined behavior|see{behavior, implemen\-tation-defined}}%
\indextext{undefined behavior|see{behavior, undefined}}%
\indextext{unspecified behavior|see{behavior, unspecified}}%
\indextext{implementation limits|see{limits, implementation}}%
\indextext{locale-specific behavior|see{behavior, locale-specific}}%
\indextext{multibyte character|see{character, multibyte}}%
\indextext{object|seealso{object model}}%
\indextext{subobject|seealso{object model}}%
\indextext{derived class!most|see{most derived class}}%
\indextext{derived object!most|see{most derived object}}%
\indextext{program execution!as-if rule|see{as-if~rule}}%
\indextext{observable behavior|see{behavior, observable}}%
\indextext{precedence of operator|see{operator, precedence of}}%
\indextext{order of evaluation in expression|see{expression, order of evaluation of}}%
\indextext{atomic operations|see{operation, atomic}}%
\indextext{multiple threads|see{threads, multiple}}%
\indextext{normative references|see{references, normative}}

\rSec1[intro.scope]{范围}

\pnum
\indextext{scope|(}%
本标准规定了程序设计语言\Cpp 实现的需求。
\Cpp 实现的首要需求就是实现语言本身，因此本标准也对\Cpp 作出了定义。
关于其它的需求和首要需求的宽限在本标准文内各处皆有描述。

\pnum
\Cpp 是一门通用型程序设计语言，基于ISO/IEC 9899:1999
\doccite{Programming languages --- C}（以下简称
\indexdefn{C!standard}\term{C标准}）拟定的程序设计语言C。
\Cpp 不仅囊括了C的功能，还提供了一些特有的数据类型以及类、模板、
异常、命名空间、操作符重载、函数名重载、
引用、自由存储管理操作符以及特有的库功能。%
\indextext{scope|)}

\rSec1[intro.refs]{规范性引用文件}

\pnum
\indextext{references!normative|(}%
下列文件对于本文件的应用是必不可少的。
凡是注日期的引用文件，仅注日期的版本适用于本文件。
凡是不注日期的引用文件，其最新版本（包括所有的修改单）适用于本文件。

\begin{itemize}
\item Ecma International, \doccite{ECMAScript Language Specification},
Standard Ecma-262, third edition, 1999.
\item ISO/IEC 2382 (all parts), \doccite{Information technology ---
Vocabulary}
\item ISO/IEC 9899:1999, \doccite{Programming languages --- C}
\item ISO/IEC 9899:1999/Cor.1:2001(E), \doccite{Programming languages --- C,
Technical Corrigendum 1}
\item ISO/IEC 9899:1999/Cor.2:2004(E), \doccite{Programming languages --- C,
Technical Corrigendum 2}
\item ISO/IEC 9899:1999/Cor.3:2007(E), \doccite{Programming languages --- C,
Technical Corrigendum 3}
\item ISO/IEC 9945:2003, \doccite{Information Technology --- Portable
Operating System Interface (POSIX)}
\item ISO/IEC 10646-1:1993, \doccite{Information technology ---
Universal Multiple-Octet Coded Character Set (UCS) --- Part 1:
Architecture and Basic Multilingual Plane}
\item ISO/IEC TR 19769:2004, \doccite{Information technology ---
Programming languages, their environments and system software interfaces
--- Extensions for the programming language C to support new character
data types}
%\item IEC 60559:1989, \doccite{Binary floating-point arithmetic for
%microprocessor systems}
\item ISO 80000-2:2009, \doccite{Quantities and units ---
Part 2: Mathematical signs and symbols
to be used in the natural sciences and technology}
\end{itemize}

\pnum
以下简称ISO/IEC 9899:1999第7章、ISO/IEC 9899:1999/Cor.1:2001第7章以及
ISO/IEC 9899:1999/Cor.2:2003第7章中描述的库为
\indexdefn{C!standard library}\term{C标准库}。
\footnote{
在条款\ref{\firstlibchapter}到条款\ref{\lastlibchapter}
以及条款\ref{diff.library}作出的限制下，
C标准库是\Cpp 标准库的子集。
}

\pnum
以下简称ISO/IEC TR 19769:2004中规定的库为
\indexdefn{C!Unicode TR}\term{C Unicode TR}。

\pnum
以下简称ISO/IEC 9945:2003中描述的操作系统接口为
\defn{POSIX}。

\pnum
以下简称Ecma-262标准中描述的ECMAScript语言规范为
\defn{ECMA-262}。
\indextext{references!normative|)}

\rSec1[intro.defs]{术语和定义}

\pnum
\indextext{definitions|(}%
ISO/IEC 2382-1:1993界定的术语和定义
以及ISO 80000-2:2009界定的术语、定义和符号适用于本文件。
以下列出了其中一部分。

\pnum
\ref{definitions}
额外定义了仅用于条款\ref{library}到条款\ref{\lastlibchapter}以及附录\ref{depr}的术语。

\pnum
仅在本标准少数几处使用的术语随用随定义，并标注为斜体。

\indexdefn{access}%
\definition{访问}{defns.access}
\defncontext{执行时动作}读取或修改对象的值

\indexdefn{argument}%
\indexdefn{argument!function call expression}
\definition{实参}{defns.argument}
\defncontext{函数调用表达式} 由圆括号界定、逗号分隔、表达式组成的列表中的项(\ref{expr.call})

\indexdefn{argument}%
\indexdefn{argument!function-like macro}%
\definition{实参}{defns.argument.macro}
\defncontext{函数式宏} 由圆括号界定、逗号分隔、预处理符号序列组成的列表中的项(\ref{cpp.replace})

\indexdefn{argument}%
\indexdefn{argument!throw expression}%
\definition{实参}{defns.argument.throw}
\defncontext{throw表达式} \tcode{throw}的操作数(\ref{expr.throw})

\indexdefn{argument}%
\indexdefn{argument!template instantiation}%
\definition{实参}{defns.argument.templ}
\defncontext{模板实例化} 由尖括号界定、逗号分隔、
\grammarterm{constant-expression}或
\grammarterm{type-id}或
\grammarterm{id-expression}组成的列表中的项(\ref{temp.arg})

\indexdefn{behavior!conditionally-supported}%
\definition{有条件支持}{defns.cond.supp}
实现不一定要支持的程序构造\\
\enternote 实现会各自注明所有规定为有条件支持但它不支持的程序构造。 \exitnote

\indexdefn{message!diagnostic}%
\definition{审错信息}{defns.diagnostic}
实现的输出信息中属于\impldef{diagnostic message}那一子集的信息

\indexdefn{type!dynamic}%
\definition{动态类型}{defns.dynamic.type}
\defncontext{广义左值} 广义左值所引用的最深层派生对象(\ref{intro.object})的类型\\
\enterexample
若指针(\ref{dcl.ptr}) \tcode{p}的静态类型是``指向\tcode{B}类的指针''，
指向派生自\tcode{B} (条款\ref{class.derived})的\tcode{D}类对象，
则表达式\tcode{*p}的动态类型为``\tcode{D}''。引用(\ref{dcl.ref})也是同理。
\exitexample

\indexdefn{type!dynamic}%
\definition{动态类型}{defns.dynamic.type.prvalue}
\defncontext{纯右值} 纯右值表达式的静态类型

\indexdefn{program!ill-formed}%
\definition{违例程序}{defns.ill.formed}
不合规(\ref{defns.well.formed})的程序

\indexdefn{behavior!implementation-defined}%
\definition{实现定义的行为}{defns.impl.defined}
在程序构造合规且数据正确的前提下，取决于具体实现，由实现各自注明的行为

\indexdefn{limits!implementation}%
\definition{实现限制}{defns.impl.limits}
实现强加给程序的限制

\indexdefn{behavior!locale-specific}%
\definition{地域特定的行为}{defns.locale.specific}
取决于当地的民族习俗、文化和语言，由实现各自注明的行为

\indexdefn{character!multibyte}%
\definition{多字节字符}{defns.multibyte}
一个或多个字节构成的表示源程序中或执行环境下的扩展字符集的某个成员的字符序列\\
\enternote 扩展字符集是基本字符集(\ref{lex.charset})的超集。 \exitnote

\indexdefn{parameter}%
\indexdefn{parameter!function}%
\indexdefn{parameter!catch clause}%
\definition{形参}{defns.parameter}
\defncontext{函数或catch子句}
作为函数声明或定义的一部分而声明的对象或引用，
或在函数或处理例程入口捕获值的异常处理例程的catch子句中声明的对象或引用

\indexdefn{parameter}%
\indexdefn{parameter!function-like macro}%
\definition{形参}{defns.parameter.macro}
\defncontext{函数式宏}
由圆括号界定、逗号分隔、标识符组成的紧跟于宏名后的列表中的项

\indexdefn{parameter}%
\indexdefn{parameter!template}%
\definition{形参}{defns.parameter.templ}
\defncontext{模板} \grammarterm{模板形参}

\indexdefn{signature}%
\definition{签名}{defns.signature}
\defncontext{函数} 名称、形参类型表(\ref{dcl.fct})以及外围命名空间（如果有的话）\\
\enternote 签名是name mangling和链接的基础。 \exitnote

\indexdefn{signature}%
\definition{签名}{defns.signature.templ}
\defncontext{函数模板} 名称、形参类型表(\ref{dcl.fct})、
外围命名空间（如果有的话）、返回类型以及模板形参表

\indexdefn{signature}%
\definition{签名}{defns.signature.spec}
\defncontext{函数模板特化} signature of the template of which it is a specialization
and its template arguments (whether explicitly specified or deduced)

\indexdefn{signature}%
\definition{签名}{defns.signature.member}
\defncontext{类成员函数} 名称、形参类型表(\ref{dcl.fct})、
所在类、\cv 限定符（如果有的话）以及\grammarterm{引用限定符}（如果有的话）

\indexdefn{signature}%
\definition{签名}{defns.signature.member.templ}
\defncontext{类成员函数模板} 名称、形参类型表(\ref{dcl.fct})、
所在类、\cv 限定符（如果有的话）、\grammarterm{引用限定符}（如果有的话）、
返回类型（如果有的话）以及模板形参表

\indexdefn{signature}%
\definition{签名}{defns.signature.member.spec}
\defncontext{类成员函数模板特化} signature of the member function template
of which it is a specialization and its template arguments (whether explicitly specified or deduced)

\indexdefn{type!static}%
\definition{静态类型}{defns.static.type}
不考虑执行时语义的情况下分析表达式所得的类型(\ref{basic.types})\\
\enternote
表达式的静态类型仅取决于该表达式在程序中出现的形式，
不会在执行时改变。 \exitnote

\indexdefn{behavior!undefined}%
\definition{未定义行为}{defns.undefined}
behavior for which this International Standard
imposes no requirements\\
\enternote Undefined behavior may be expected when
this International Standard omits any explicit
definition of behavior or when a program uses an erroneous construct or erroneous data.
Permissible undefined behavior ranges
from ignoring the situation completely with unpredictable results, to
behaving during translation or program execution in a documented manner
characteristic of the environment (with or without the issuance of a
diagnostic message), to terminating a translation or execution (with the
issuance of a diagnostic message). Many erroneous program constructs do
not engender undefined behavior; they are required to be diagnosed.
\exitnote

\indexdefn{behavior!unspecified}%
\definition{未规定行为}{defns.unspecified}
在程序构造合规且数据正确的前提下，取决于具体实现的行为\\
\enternote
实现不必注明哪种行为会发生。
通常情况下本标准会描述出可能的行为范围。
\exitnote

\indexdefn{program!well-formed}%
\definition{合规程序}{defns.well.formed}
按照语法规则、\transuwave{可审错的语义规则}以及一处定义规则(\ref{basic.def.odr})
构造的\Cpp 程序%
\indextext{definitions|)}

\rSec1[intro.compliance]{实现合规度}

\pnum
\indextext{conformance requirements|(}%
\indextext{conformance requirements!general|(}%
\defn{可审错规则}集由本标准所有的语法语义规则组成，
但不包括被显式地记为``无需审错''
或描述为导致``未定义行为''的规则。

\pnum
\indextext{conformance requirements!method of description}%
本标准仅规定\Cpp 实现的需求，
还存在某些需求，它们约定俗成地成为程序的、程序某部分的或是程序执行时的需求，且往往易于理解。
此类需求具有下列含义：
\begin{itemize}

\item
若程序未违反本标准任何一条规则，符合标准的实现应在自身的资源限额内接受并且正确地执行
\footnote{所谓``正确执行''也包括未定义行为，取决于要处理的数据；见\ref{intro.defs}和\ref{intro.execution}。}
该程序。

\item
\indextext{message!diagnostic}%
若程序违反了本标准任何一条可审错规则，
或使用了本标准描述为``有条件支持''而实现并不支持的程序构造，
符合标准的实现应至少发布一条审错信息。

\item
\indextext{behavior!undefined}%
若程序违反了本标准任何一条无需审错的规则，
实现如何对待该程序本标准未作规定。

\end{itemize}

\pnum
\indextext{conformance requirements!library|(}%
\indextext{conformance requirements!classes}%
\indextext{conformance requirements!class templates}%
对于类和类模板，库条款给出了部分定义。
私有成员(条款\ref{class.access})未给出，
实现应根据库条款的描述提供它们以完成定义。

\pnum
对于函数、函数模板、对象和值，库条款给出了声明。
实现应给出与库条款的描述一致的定义。

\pnum
标准库定义的名称都具有命名空间作用域(\ref{basic.namespace})。
\Cpp 翻译单元(\ref{lex.phases})通过包含适当的标准库头文件(\ref{cpp.include})访问这些名称。

\pnum
标准库中的模板、类、函数和对象都是外部链接(\ref{basic.link})。
将翻译单元合并成完整的\Cpp 程序时(\ref{lex.phases})，如有必要，由实现为标准库中的实体提供定义。%
\indextext{conformance requirements!library|)}

\pnum
实现按定义分为两种：
\defn{宿主式实现}和\defn{独立式实现}。
对于宿主式实现，本标准定义了其可用库的集合。
独立式实现可以脱离于操作系统执行程序，并有一套
包含某些语言支持库(\ref{compliance})的
\impldef{required libraries for freestanding implementation}库的集合

\pnum
符合标准的实现允许作扩展（包括一些附加的库函数）的前提是不改变任何合规程序的行为。
若程序使用了本标准视为违例的扩展，实现应向程序出示审错信息，
同时不影响程序的编译和执行。

\pnum
实现都应提供相应的文档，
标示出所有它不支持的有条件支持的构造\indextext{behavior!conditionally-supported}，
定义出所有地域特定的特性。
\footnote{文档中还应定义出实现定义的行为；见\ref{intro.execution}。}%
\indextext{conformance requirements!general|)}%
\indextext{conformance requirements|)}%

\rSec1[intro.structure]{本标准的结构}

\pnum
\indextext{standard!structure of|(}%
\indextext{standard!structure of}%
条款\ref{lex}到\ref{cpp}描述程序设计语言\Cpp，
并按\ref{syntax}所定的形式详尽地描述了语法规定。
为方便起见，附录\ref{gram}重复列出了所有语法规则。

\pnum
条款\ref{\firstlibchapter}到\ref{\lastlibchapter}以及附录\ref{depr}
（\defn{库条款}）描述\Cpp 标准库，
并按条款\ref{library}所定的形式详尽地描述了模板、类、函数、常量和宏这些库组件。

\pnum
附录\ref{implimits}列出符合标准的实现的推荐最低要求。

\pnum
附录\ref{diff}汇总了\Cpp 自首次出版说明以来经历的演变，
并详细阐释了\Cpp 和 C\@之间的差别。
\Cpp 某些功能仅为兼容目的存在，附录\ref{depr}描述了这些功能。

\pnum
本标准通篇示例都由``\enterexample''引出，由``\exitexample''结束；
通篇注释都由``\enternote'引出，由``\exitnote''结束。
两者可能嵌套。%
\indextext{standard!structure of|)}

\rSec1[syntax]{语法表示}

\pnum
\indextext{notation!syntax|(}%
本标准使用的语法表示叙述如下：
语法条目以\grammarterm{斜体}表示，
\transuwave{字面上的单词和字符}以\tcode{等宽}字体表示；
各个选择项罗列在各行，少数情况下当选择项太多时用短语``下列之一''标记。
内容太长一行不能表示的选择项会在后续行中继续书写，后续行会在第一行的基础上缩进。
可选的终结符或非终结符由下标``\opt''表示，因此，

\begin{ncbnf}
\terminal{\{} 表达式\opt{} \terminal{\}}
\end{ncbnf}

表示内嵌在花括号中的表达式。%

\pnum
语法条目一般按以下规则命名：
\begin{itemize}
\item \grammarterm{X名}是\transuwave{标识符在决定它含义的某处上下文中的使用}（如\grammarterm{类名}、
\grammarterm{typedef名}）。
\item \grammarterm{X标识符}是不带上下文含义的标识符
（如\grammarterm{限定标识符}）。
\item \grammarterm{X列}是一个或多个\grammarterm{X}且没有任何分隔符
（如\grammarterm{声明列}就是声明的序列）。
\item \grammarterm{X表}是逗号分隔的一个或多个\grammarterm{X}
（如\grammarterm{表达式表}就是逗号分隔的表达式序列）。
\end{itemize}%
\indextext{notation!syntax|)}

\rSec1[intro.memory]{The \Cpp memory model}

\pnum
\indextext{memory model|(}%
The fundamental storage unit in the \Cpp memory model is the
\defn{byte}.
A byte is at least large enough to contain any member of the basic
\indextext{character set!basic execution}%
execution character set~(\ref{lex.charset})
and the eight-bit code units of the Unicode UTF-8 encoding form
and is composed of a contiguous sequence of
bits, the number of which is \impldef{bits in a byte}. The least
significant bit is called the \defn{low-order bit}; the most
significant bit is called the \defn{high-order bit}. The memory
available to a \Cpp program consists of one or more sequences of
contiguous bytes. Every byte has a unique address.

\pnum
\enternote The representation of types is described
in~\ref{basic.types}. \exitnote

\pnum
A \defn{memory location} is either an object of scalar type or a maximal
sequence of adjacent bit-fields all having non-zero width. \enternote Various
features of the language, such as references and virtual functions, might
involve additional memory locations that are not accessible to programs but are
managed by the implementation. \exitnote Two or more threads of
execution~(\ref{intro.multithread}) can access separate memory
locations without interfering with each other.

\pnum
\enternote Thus a bit-field and an adjacent non-bit-field are in separate memory
locations, and therefore can be concurrently updated by two threads of execution
without interference. The same applies to two bit-fields, if one is declared
inside a nested struct declaration and the other is not, or if the two are
separated by a zero-length bit-field declaration, or if they are separated by a
non-bit-field declaration. It is not safe to concurrently update two bit-fields
in the same struct if all fields between them are also bit-fields of non-zero
width. \exitnote

\pnum
\enterexample A structure declared as

\begin{codeblock}
struct {
  char a;
  int b:5,
  c:11,
  :0,
  d:8;
  struct {int ee:8;} e;
}
\end{codeblock}

contains four separate memory locations: The field \tcode{a} and bit-fields
\tcode{d} and \tcode{e.ee} are each separate memory locations, and can be
modified concurrently without interfering with each other. The bit-fields
\tcode{b} and \tcode{c} together constitute the fourth memory location. The
bit-fields \tcode{b} and \tcode{c} cannot be concurrently modified, but
\tcode{b} and \tcode{a}, for example, can be. \exitexample%
\indextext{memory model|)}

\rSec1[intro.object]{The \Cpp object model}

\pnum
\indextext{object model|(}%
\indextext{object}%
The constructs in a \Cpp program create, destroy, refer to, access, and
manipulate objects. An \defn{object} is a region of storage.
\enternote A function is not an object, regardless of whether or not it
occupies storage in the way that objects do. \exitnote An object is
created by a \grammarterm{definition}~(\ref{basic.def}), by a
\grammarterm{new-expression}~(\ref{expr.new}) or by the
implementation~(\ref{class.temporary}) when needed. The properties of an
object are determined when the object is created. An object can have a
\term{name}~(Clause~\ref{basic}). An object has a \term{storage
duration}~(\ref{basic.stc}) which influences its
\term{lifetime}~(\ref{basic.life}). An object has a
\term{type}~(\ref{basic.types}). The term \defn{object type} refers to
the type with which the object is created.
Some objects are
\term{polymorphic}~(\ref{class.virtual}); the implementation
generates information associated with each such object that makes it
possible to determine that object's type during program execution. For
other objects, the interpretation of the values found therein is
determined by the type of the \grammarterm{expression}{s} (Clause~\ref{expr})
used to access them.

\pnum
\indextext{subobject}%
Objects can contain other objects, called \defnx{subobjects}{subobject}.
A subobject can be
a \defn{member subobject}~(\ref{class.mem}), a \defn{base class subobject}
(Clause~\ref{class.derived}), or an array element.
\indextext{object!complete}%
An object that is not a subobject of any other object is called a \defn{complete
object}.

\pnum
For every object \tcode{x}, there is some object called the
\defn{complete object of} \tcode{x}, determined as follows:

\begin{itemize}

\item
If \tcode{x} is a complete object, then \tcode{x} is the complete
object of \tcode{x}.

\item
Otherwise, the complete object of \tcode{x} is the complete object
of the (unique) object that contains \tcode{x}.

\end{itemize}

\pnum
If a complete object, a data member~(\ref{class.mem}), or an array element is of
class type, its type is considered the \defn{most derived
class}, to distinguish it from the class type of any base class subobject;
an object of a most derived class type or of a non-class type is called a
\defn{most derived object}.

\pnum
\indextext{most derived object!bit-field}%
Unless it is a bit-field~(\ref{class.bit}), a most derived object shall have a
non-zero size and shall occupy one or more bytes of storage. Base class
subobjects may have zero size. An object of trivially copyable or
standard-layout type~(\ref{basic.types}) shall occupy contiguous bytes of
storage.

\pnum
\indextext{most derived object!bit-field}%
\indextext{most derived object!zero size subobject}%
Unless an object is a bit-field or a base class subobject of zero size, the
address of that object is the address of the first byte it occupies. Two
objects that are not bit-fields
may have the same address if one is a subobject of the other, or if at least
one is a base class subobject of zero size and they are of different types;
otherwise, they shall have distinct addresses.\footnote{Under the ``as-if'' rule an
implementation is allowed to store two objects at the same machine address or
not store an object at all if the program cannot observe the
difference~(\ref{intro.execution}).}

\enterexample
\begin{codeblock}
static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &test1 != &test2;      // always true
\end{codeblock}
\exitexample

\pnum
\enternote 
\Cpp  provides a variety of fundamental types and several ways of composing
new types from existing types~(\ref{basic.types}).
\exitnote%
\indextext{object model|)}

\rSec1[intro.execution]{Program execution}

\pnum
\indextext{program execution|(}%
\indextext{program execution!abstract machine|(}%
The semantic descriptions in this International Standard define a
parameterized nondeterministic abstract machine. This International
Standard places no requirement on the structure of conforming
implementations. In particular, they need not copy or emulate the
structure of the abstract machine.
\indextext{as-if~rule}%
\indextext{behavior!observable}%
Rather, conforming implementations are required to emulate (only) the observable
behavior of the abstract machine as explained below.\footnote{This provision is
sometimes called the ``as-if'' rule, because an implementation is free to
disregard any requirement of this International Standard as long as the result
is \emph{as if} the requirement had been obeyed, as far as can be determined
from the observable behavior of the program. For instance, an actual
implementation need not evaluate part of an expression if it can deduce that its
value is not used and that no
\indextext{side effects}%
side effects affecting the
observable behavior of the program are produced.}

\indextext{behavior!implementation-defined}%
\pnum
Certain aspects and operations of the abstract machine are described in this
International Standard as implementation-defined (for example,
\tcode{sizeof(int)}). These constitute the parameters of the abstract machine.
Each implementation shall include documentation describing its characteristics
and behavior in these respects.\footnote{This documentation also includes
conditionally-supported constructs and locale-specific behavior.
See~\ref{intro.compliance}.} Such documentation shall define the instance of the
abstract machine that corresponds to that implementation (referred to as the
``corresponding instance'' below).

\indextext{behavior!unspecified}%
\pnum
Certain other aspects and operations of the abstract machine are
described in this International Standard as unspecified (for example,
evaluation of expressions in a \grammarterm{new-initializer} if the allocation
function fails to allocate memory~(\ref{expr.new})). Where possible, this
International Standard defines a set of allowable behaviors. These
define the nondeterministic aspects of the abstract machine. An instance
of the abstract machine can thus have more than one possible execution
for a given program and a given input.

\indextext{behavior!undefined}%
\pnum
Certain other operations are described in this International Standard as
undefined (for example, the effect of
attempting to modify a \tcode{const} object).
\enternote This International Standard imposes no requirements on the
behavior of programs that contain undefined behavior. \exitnote

\indextext{program!well-formed}%
\indextext{behavior!observable}%
\pnum
A conforming implementation executing a well-formed program shall
produce the same observable behavior as one of the possible executions
of the corresponding instance of the abstract machine with the
same program and the same input. However, if any such execution contains an undefined operation, this International Standard places no
requirement on the implementation executing that program with that input
(not even with regard to operations preceding the first undefined
operation).

\indextext{behavior!unspecified}%
\indextext{behavior!undefined}%
\indextext{behavior!on receipt of signal}%
\indextext{signal}%
\pnum
If a signal handler is executed as a result of a call to the \tcode{raise}
function, then the execution of the handler is sequenced after the invocation
of the \tcode{raise} function and before its return.
\enternote When a signal is received for another reason, the execution of the
signal handler is usually unsequenced with respect to the rest of the program.
\exitnote

\pnum
An instance of each object with automatic storage
duration~(\ref{basic.stc.auto}) is associated with each entry into its
block. Such an object exists and retains its last-stored value during
the execution of the block and while the block is suspended (by a call
of a function or receipt of a signal).

\indextext{conformance requirements}
\pnum
The least requirements on a conforming implementation are:

\begin{itemize}

\item
Access to volatile objects are evaluated strictly according to the
rules of the abstract machine.

\item
At program termination, all data written into files shall be
identical to one of the possible results that execution of the program
according to the abstract semantics would have produced.

\item
The input and output dynamics of interactive devices shall take
place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is
\impldef{interactive device}.

\end{itemize}

These collectively are referred to as the
\defnx{observable behavior}{behavior!observable} of the program.
\enternote More stringent correspondences between abstract and actual
semantics may be defined by each implementation. \exitnote

\pnum
\indextext{operator!precedence of}%
\indextext{expression!order of evaluation of}%
\enternote Operators can be regrouped according to the usual
mathematical rules only where the operators really are associative or
commutative.\footnote{Overloaded operators are never assumed to be associative or
commutative. }
For example, in the following fragment
\begin{codeblock}
int a, b;
/*...*/
a = a + 32760 + b + 5;
\end{codeblock}
the expression statement behaves exactly the same as
\begin{codeblock}
a = (((a + 32760) + b) + 5);
\end{codeblock}
due to the associativity and precedence of these operators. Thus, the
result of the sum \tcode{(a + 32760)} is next added to \tcode{b}, and
that result is then added to 5 which results in the value assigned to
\tcode{a}. On a machine in which overflows produce an exception and in
which the range of values representable by an \tcode{int} is
\crange{-32768}{+32767}, the implementation cannot rewrite this
expression as
\begin{codeblock}
a = ((a + b) + 32765);
\end{codeblock}
since if the values for \tcode{a} and \tcode{b} were, respectively,
-32754 and -15, the sum \tcode{a + b} would produce an exception while
the original expression would not; nor can the expression be rewritten
either as
\begin{codeblock}
a = ((a + 32765) + b);
\end{codeblock}
or
\begin{codeblock}
a = (a + (b + 32765));
\end{codeblock}
since the values for \tcode{a} and \tcode{b} might have been,
respectively, 4 and -8 or -17 and 12. However on a machine in which
overflows do not produce an exception and in which the results of
overflows are reversible, the above expression statement can be
rewritten by the implementation in any of the above ways because the
same result will occur. \exitnote

\pnum
\indextext{full-expression}%
A \defn{full-expression} is an expression that is not a
subexpression of another expression.
\enternote
in some contexts, such as unevaluated operands, a syntactic
subexpression is considered a full-expression
(Clause~\ref{expr}).
\exitnote
If a language construct is defined
to produce an implicit call of a function, a use of the language
construct is considered to be an expression for the purposes of this
definition. A call to a destructor generated at the end of the lifetime
of an object other than a temporary object is an implicit
full-expression. Conversions applied to the result of an expression in
order to satisfy the requirements of the language construct in which the
expression appears are also considered to be part of the
full-expression.

\enterexample
\begin{codeblock}
struct S {
  S(int i): I(i) { }
  int& v() { return I; }
private:
  int I;
};

 S s1(1);           // full-expression is call of \tcode{S::S(int)}
 S s2 = 2;          // full-expression is call of \tcode{S::S(int)}

void f() {
  if (S(3).v())     // full-expression includes lvalue-to-rvalue and
                    // \tcode{int} to \tcode{bool} conversions, performed before
                    // temporary is deleted at end of full-expression
  { }
}
\end{codeblock}
\exitexample

\pnum
\enternote The evaluation of a full-expression can include the
evaluation of subexpressions that are not lexically part of the
full-expression. For example, subexpressions involved in evaluating
default arguments~(\ref{dcl.fct.default}) are considered to
be created in the expression that calls the function, not the expression
that defines the default argument. \exitnote

\pnum
\indextext{value computation|(}%
Reading an object designated by a \tcode{volatile}
glvalue~(\ref{basic.lval}), modifying an object, calling a library I/O
function, or calling a function that does any of those operations are
all
\defn{side effects}, which are changes in the state of the execution
environment. \defn{Evaluation} of an expression (or a
sub-expression) in general includes both value computations (including
determining the identity of an object for glvalue evaluation and fetching
a value previously assigned to an object for prvalue evaluation) and
initiation of side effects. When a call to a library I/O function
returns or an access to a \tcode{volatile} object is evaluated the side
effect is considered complete, even though some external actions implied
by the call (such as the I/O itself) or by the \tcode{volatile} access
may not have completed yet.

\pnum
\defn{Sequenced before} is an asymmetric, transitive, pair-wise relation between
evaluations executed by a single thread~(\ref{intro.multithread}), which induces
a partial order among those evaluations. Given any two evaluations \term{A} and
\term{B}, if \term{A} is sequenced before \term{B}
(or, equivalently, \term{B} is \defn{sequenced after} \term{A}),
then the execution of
\term{A} shall precede the execution of \term{B}. If \term{A} is not sequenced
before \term{B} and \term{B} is not sequenced before \term{A}, then \term{A} and
\term{B} are \defn{unsequenced}. \enternote The execution of unsequenced
evaluations can overlap. \exitnote Evaluations \term{A} and \term{B} are
\defn{indeterminately sequenced} when either \term{A} is sequenced before
\term{B} or \term{B} is sequenced before \term{A}, but it is unspecified which.
\enternote Indeterminately sequenced evaluations cannot overlap, but either
could be executed first. \exitnote

\pnum
Every
\indextext{value computation}%
value computation and
\indextext{side effects}%
side effect associated with a full-expression is
sequenced before every value computation and side effect associated with the
next full-expression to be evaluated.\footnote{As specified
in~\ref{class.temporary}, after a full-expression is evaluated, a sequence of
zero or more invocations of destructor functions for temporary objects takes
place, usually in reverse order of the construction of each temporary object.}

\pnum
\indextext{evaluation!unspecified order~of}%
Except where noted, evaluations of operands of individual operators and
of subexpressions of individual expressions are unsequenced. \enternote
In an expression that is evaluated more than once during the execution
of a program, unsequenced and indeterminately sequenced evaluations of
its subexpressions need not be performed consistently in different
evaluations. \exitnote The value computations of the operands of an
operator are sequenced before the value computation of the result of the
operator. If a
\indextext{side effects}%
side effect on a memory location~(\ref{intro.memory}) is unsequenced
relative to either another side effect on the same memory location or
a value computation using the value of any object in the same memory location,
and they are not potentially concurrent~(\ref{intro.multithread}),
the behavior is undefined.
\enternote
The next section imposes similar, but more complex restrictions on
potentially concurrent computations.
\exitnote

\enterexample

\begin{codeblock}
void f(int, int);
void g(int i, int* v) {
  i = v[i++];         // the behavior is undefined
  i = 7, i++, i++;    // \tcode{i} becomes \tcode{9}

  i = i++ + 1;        // the behavior is undefined
  i = i + 1;          // the value of \tcode{i} is incremented

  f(i = -1, i = -1);  // the behavior is undefined
}
\end{codeblock}
\exitexample

When calling a function (whether or not the function is inline), every
\indextext{value computation}%
value computation and
\indextext{side effects}%
side effect associated with any argument
expression, or with the postfix expression designating the called
function, is sequenced before execution of every expression or statement
in the body of the called function. \enternote
Value computations and
side effects associated with different argument expressions are
unsequenced. \exitnote
For each function invocation \term{F},
for every evaluation \term{A} that occurs within \term{F} and
every evaluation \term{B} that does not occur within \term{F} but
is evaluated on the same thread and as part of the same signal handler (if any),
either \term{A} is sequenced before \term{B} or
\term{B} is sequenced before \term{A}.
\footnote{In other words, function executions do not interleave with
each other.}
\enternote
If \term{A} and \term{B} would not otherwise be sequenced then they are
indeterminately sequenced.
\exitnote
Several contexts in \Cpp  cause evaluation of a function call, even
though no corresponding function call syntax appears in the translation
unit.
\enterexample
Evaluation of a \grammarterm{new-expression} invokes one or more allocation
and constructor functions; see~\ref{expr.new}. For another example,
invocation of a conversion function~(\ref{class.conv.fct}) can arise in
contexts in which no function call syntax appears.
\exitexample
The sequencing constraints on the execution of the called function (as
described above) are features of the function calls as evaluated,
whatever the syntax of the expression that calls the function might be.%
\indextext{value computation|)}%
\indextext{program execution|)}

\rSec1[intro.multithread]{Multi-threaded executions and data races}

\pnum
\indextext{threads!multiple|(}%
\indextext{operation!atomic|(}%
A \defn{thread of execution} (also known as a \defn{thread}) is a single flow of
control within a program, including the initial invocation of a specific
top-level function, and recursively including every function invocation
subsequently executed by the thread. \enternote When one thread creates another,
the initial call to the top-level function of the new thread is executed by the
new thread, not by the creating thread. \exitnote Every thread in a program can
potentially access every object and function in a program.\footnote{An object
with automatic or thread storage duration~(\ref{basic.stc}) is associated with
one specific thread, and can be accessed by a different thread only indirectly
through a pointer or reference~(\ref{basic.compound}).} Under a hosted
implementation, a \Cpp program can have more than one thread running
concurrently. The execution of each thread proceeds as defined by the remainder
of this standard. The execution of the entire program consists of an execution
of all of its threads. \enternote Usually the execution can be viewed as an
interleaving of all its threads. However, some kinds of atomic operations, for
example, allow executions inconsistent with a simple interleaving, as described
below. \exitnote Under a freestanding implementation, it is \impldef{number of
threads in a program under a freestanding implementation} whether a program can
have more than one thread of execution.

\pnum
A signal handler that is executed as a result of a call to the \tcode{raise}
function belongs to the same thread of execution as the call to the
\tcode{raise} function. Otherwise it is unspecified which thread of execution
contains a signal handler invocation.

\pnum
Implementations should ensure that all unblocked threads eventually make
progress. \enternote Standard library functions may silently block on I/O or
locks. Factors in the execution environment, including externally-imposed thread
priorities, may prevent an implementation from making certain guarantees of
forward progress. \exitnote

\pnum
Executions of atomic functions
that are either defined to be lock-free~(\ref{atomics.flag})
or indicated as lock-free~(\ref{atomics.lockfree})
are \indexdefn{lock-free executions}\term{lock-free executions}.
\begin{itemize}
\item
  If there is only one unblocked thread,
  a lock-free execution in that thread shall complete.
  \enternote
    Concurrently executing threads
    may prevent progress of a lock-free execution.
    For example,
    this situation can occur
    with load-locked store-conditional implementations.
    This property is sometimes termed obstruction-free.
  \exitnote
\item
  When one or more lock-free executions run concurrently,
  at least one should complete.
  \enternote
    It is difficult for some implementations
    to provide absolute guarantees to this effect,
    since repeated and particularly inopportune interference
    from other threads
    may prevent forward progress,
    e.g.,
    by repeatedly stealing a cache line
    for unrelated purposes
    between load-locked and store-conditional instructions.
    Implementations should ensure
    that such effects cannot indefinitely delay progress
    under expected operating conditions,
    and that such anomalies
    can therefore safely be ignored by programmers.
    Outside this International Standard,
    this property is sometimes termed lock-free.
  \exitnote
\end{itemize}

\pnum
The value of an object visible to a thread \term{T} at a particular point is the
initial value of the object, a value assigned to the object by \term{T}, or a
value assigned to the object by another thread, according to the rules below.
\enternote In some cases, there may instead be undefined behavior. Much of this
section is motivated by the desire to support atomic operations with explicit
and detailed visibility constraints. However, it also implicitly supports a
simpler view for more restricted programs. \exitnote

\pnum
Two expression evaluations \defn{conflict} if one of them modifies a memory
location~(\ref{intro.memory}) and the other one reads or modifies the same
memory location.

\pnum
The library defines a number of atomic operations (Clause~\ref{atomics}) and
operations on mutexes (Clause~\ref{thread}) that are specially identified as
synchronization operations. These operations play a special role in making
assignments in one thread visible to another. A synchronization operation on one
or more memory locations is either a consume operation, an acquire operation, a
release operation, or both an acquire and release operation. A synchronization
operation without an associated memory location is a fence and can be either an
acquire fence, a release fence, or both an acquire and release fence. In
addition, there are relaxed atomic operations, which are not synchronization
operations, and atomic read-modify-write operations, which have special
characteristics. \enternote For example, a call that acquires a mutex will
perform an acquire operation on the locations comprising the mutex.
Correspondingly, a call that releases the same mutex will perform a release
operation on those same locations. Informally, performing a release operation on
\term{A} forces prior
\indextext{side effects}%
side effects on other memory locations to become visible
to other threads that later perform a consume or an acquire operation on
\term{A}. ``Relaxed'' atomic operations are not synchronization operations even
though, like synchronization operations, they cannot contribute to data races.
\exitnote

\pnum
All modifications to a particular atomic object \term{M} occur in some
particular total order, called the \defn{modification order} of \term{M}. If
\term{A} and \term{B} are modifications of an atomic object \term{M} and
\term{A} happens before (as defined below) \term{B}, then \term{A} shall precede
\term{B} in the modification order of \term{M}, which is defined below.
\enternote This states that the modification orders must respect the ``happens
before'' relationship. \exitnote \enternote There is a separate order for each
atomic object. There is no requirement that these can be combined into a single
total order for all objects. In general this will be impossible since different
threads may observe modifications to different objects in inconsistent orders.
\exitnote

\pnum
A \defn{release sequence} headed by a release operation \term{A} on an atomic object
\term{M} is a maximal contiguous sub-sequence of
\indextext{side effects}%
side effects in the
modification order of \term{M}, where the first operation is \tcode{A}, and
every subsequent operation

\begin{itemize}
\item is performed by the same thread that performed \tcode{A}, or
\item is an atomic read-modify-write operation.
\end{itemize}

\pnum
Certain library calls \defn{synchronize with} other library calls performed by
another thread. For example, an atomic store-release synchronizes with a
load-acquire that takes its value from the store~(\ref{atomics.order}).
\enternote Except in the specified cases, reading a later value does not
necessarily ensure visibility as described below. Such a requirement would
sometimes interfere with efficient implementation. \exitnote \enternote The
specifications of the synchronization operations define when one reads the value
written by another. For atomic objects, the definition is clear. All operations
on a given mutex occur in a single total order. Each mutex acquisition ``reads
the value written'' by the last mutex release. \exitnote

\pnum
An evaluation \term{A} \defn{carries a dependency} to an evaluation \term{B} if

\begin{itemize}

\item
the value of \term{A} is used as an operand of \term{B}, unless:
\begin{itemize}

\item
\term{B} is an invocation of any specialization of
\tcode{std::kill_dependency}~(\ref{atomics.order}), or

\item
\term{A} is the left operand of a built-in logical AND (\tcode{\&\&},
see~\ref{expr.log.and}) or logical OR (\tcode{||}, see~\ref{expr.log.or}) 
operator, or

\item
\term{A} is the left operand of a conditional (\tcode{?:}, see~\ref{expr.cond})
operator, or

\item
\term{A} is the left operand of the built-in comma (\tcode{,})
operator~(\ref{expr.comma}); \end{itemize} or

\item
\term{A} writes a scalar object or bit-field \term{M}, \term{B} reads the value
written by \term{A} from \term{M}, and \term{A} is sequenced before \term{B}, or

\item
for some evaluation \term{X}, \term{A} carries a dependency to \term{X}, and 
\term{X} carries a dependency to \term{B}.

\end{itemize}

\enternote ``Carries a dependency to'' is a subset of ``is sequenced before'',
and is similarly strictly intra-thread. \exitnote

\pnum
An evaluation \term{A} is \defn{dependency-ordered before} an evaluation
\term{B} if
\begin{itemize}

\item
\term{A} performs a release operation on an atomic object \term{M}, and, in
another thread, \term{B} performs a consume operation on \term{M} and reads a
value written by any
\indextext{side effects}%
side effect in the release sequence headed by \term{A}, or

\item
for some evaluation \term{X}, \term{A} is dependency-ordered before \term{X} and
\term{X} carries a dependency to \term{B}.

\end{itemize}
\enternote The relation ``is dependency-ordered before'' is analogous to
``synchronizes with'', but uses release/consume in place of release/acquire.
\exitnote

\pnum
An evaluation \term{A} \defn{inter-thread happens before} an evaluation \term{B}
if

\begin{itemize}

\item
\term{A} synchronizes with \term{B}, or

\item
\term{A} is dependency-ordered before \term{B}, or

\item
for some evaluation \term{X}

\begin{itemize}
\item
\term{A} synchronizes with \term{X} and \term{X} is sequenced before \term{B},
or

\item
\term{A} is sequenced before \term{X} and \term{X} inter-thread happens before
\term{B}, or

\item
\term{A} inter-thread happens before \term{X} and \term{X} inter-thread happens
before \term{B}.
\end{itemize}
\end{itemize}

\enternote The ``inter-thread happens before'' relation describes arbitrary
concatenations of ``sequenced before'', ``synchronizes with'' and
``dependency-ordered before'' relationships, with two exceptions. The first
exception is that a concatenation is not permitted to end with
``dependency-ordered before'' followed by ``sequenced before''. The reason for
this limitation is that a consume operation participating in a
``dependency-ordered before'' relationship provides ordering only with respect
to operations to which this consume operation actually carries a dependency. The
reason that this limitation applies only to the end of such a concatenation is
that any subsequent release operation will provide the required ordering for a
prior consume operation. The second exception is that a concatenation is not
permitted to consist entirely of ``sequenced before''. The reasons for this
limitation are (1) to permit ``inter-thread happens before'' to be transitively
closed and (2) the ``happens before'' relation, defined below, provides for
relationships consisting entirely of ``sequenced before''. \exitnote

\pnum
An evaluation \term{A} \defn{happens before} an evaluation \term{B}
(or, equivalently, \term{B} \defn{happens after} \term{A}) if:

\begin{itemize}
\item \term{A} is sequenced before \term{B}, or
\item \term{A} inter-thread happens before \term{B}.
\end{itemize}

The implementation shall ensure that no program execution demonstrates a cycle
in the ``happens before'' relation. \enternote This cycle would otherwise be
possible only through the use of consume operations. \exitnote

\pnum
A \defnx{visible side effect}{side effects!visible} \term{A} on a scalar object or bit-field \term{M}
with respect to a value computation \term{B} of \term{M} satisfies the
conditions:

\begin{itemize}
\item \term{A} happens before \term{B} and
\item there is no other
\indextext{side effects}%
side effect \term{X} to \term{M} such that \term{A}
happens before \term{X} and \term{X} happens before \term{B}.
\end{itemize}

The value of a non-atomic scalar object or bit-field \term{M}, as determined by
evaluation \term{B}, shall be the value stored by the
\indextext{side effects!visible}%
visible side effect
\term{A}. \enternote If there is ambiguity about which side effect to a
non-atomic object or bit-field is visible, then the behavior is either
unspecified or undefined. \exitnote \enternote This states that operations on
ordinary objects are not visibly reordered. This is not actually detectable
without data races, but it is necessary to ensure that data races, as defined
below, and with suitable restrictions on the use of atomics, correspond to data
races in a simple interleaved (sequentially consistent) execution. \exitnote

\pnum
The value of an
atomic object \term{M}, as determined by evaluation \term{B}, shall be the value
stored by some
side effect \term{A} that modifies \term{M}, where \term{B} does not happen
before \term{A}.
\enternote
The set of such side effects is also restricted by the rest of the rules
described here, and in particular, by the coherence requirements below.
\exitnote

\pnum
If an operation \term{A} that modifies an atomic object \term{M} happens before
an operation \term{B} that modifies \term{M}, then \term{A} shall be earlier
than \term{B} in the modification order of \term{M}. \enternote This requirement
is known as write-write coherence. \exitnote

\pnum
If a
\indextext{value computation}%
value computation \term{A} of an atomic object \term{M} happens before a
value computation \term{B} of \term{M}, and \term{A} takes its value from a side
effect \term{X} on \term{M}, then the value computed by \term{B} shall either be
the value stored by \term{X} or the value stored by a
\indextext{side effects}%
side effect \term{Y} on
\term{M}, where \term{Y} follows \term{X} in the modification order of \term{M}.
\enternote This requirement is known as read-read coherence. \exitnote

\pnum
If a
\indextext{value computation}%
value computation \term{A} of an atomic object \term{M} happens before an
operation \term{B} that modifies \term{M}, then \term{A} shall take its value from a side
effect \term{X} on \term{M}, where \term{X} precedes \term{B} in the
modification order of \term{M}. \enternote This requirement is known as
read-write coherence. \exitnote

\pnum
If a
\indextext{side effects}%
side effect \term{X} on an atomic object \term{M} happens before a value
computation \term{B} of \term{M}, then the evaluation \term{B} shall take its
value from \term{X} or from a
\indextext{side effects}%
side effect \term{Y} that follows \term{X} in the
modification order of \term{M}. \enternote This requirement is known as
write-read coherence. \exitnote

\pnum
\enternote The four preceding coherence requirements effectively disallow
compiler reordering of atomic operations to a single object, even if both
operations are relaxed loads. This effectively makes the cache coherence
guarantee provided by most hardware available to \Cpp atomic operations.
\exitnote

\pnum
\enternote The value observed by a load of an atomic depends on the ``happens
before'' relation, which depends on the values observed by loads of atomics.
The intended reading is that there must exist an
association of atomic loads with modifications they observe that, together with
suitably chosen modification orders and the ``happens before'' relation derived
as described above, satisfy the resulting constraints as imposed here. \exitnote

\pnum
\indextext{potentially~concurrent}%
Two actions are \term{potentially concurrent} if
\begin{itemize}
\item they are performed by different threads, or
\item they are unsequenced, and at least one is performed by a signal handler.
\end{itemize}
\indextext{data~race}%
The execution of a program contains a \defn{data race} if it contains two
potentially concurrent conflicting actions, at least one of which is not atomic,
and neither happens before the other,
except for the special case for signal handlers described below.
Any such data race results in undefined
behavior. \enternote It can be shown that programs that correctly use mutexes
and \tcode{memory_order_seq_cst} operations to prevent all data races and use no
other synchronization operations behave as if the operations executed by their
constituent threads were simply interleaved, with each
\indextext{value computation}%
value computation of an
object being taken from the last
\indextext{side effects}%
side effect on that object in that
interleaving. This is normally referred to as ``sequential consistency''.
However, this applies only to data-race-free programs, and data-race-free
programs cannot observe most program transformations that do not change
single-threaded program semantics. In fact, most single-threaded program
transformations continue to be allowed, since any program that behaves
differently as a result must perform an undefined operation. \exitnote

\pnum
Two accesses to the same object of type \tcode{volatile sig_atomic_t} do not
result in a data race if both occur in the same thread, even if one or more
occurs in a signal handler. For each signal handler invocation, evaluations
performed by the thread invoking a signal handler can be divided into two
groups \placeholder{A} and \placeholder{B}, such that no evaluations in
\placeholder{B} happen before evaluations in \placeholder{A}, and the
evaluations of such \tcode{volatile sig_atomic_t} objects take values as though
all evaluations in \placeholder{A} happened before the execution of the signal
handler and the execution of the signal handler happened before all evaluations
in \placeholder{B}.

\pnum
\enternote Compiler transformations that introduce assignments to a potentially
shared memory location that would not be modified by the abstract machine are
generally precluded by this standard, since such an assignment might overwrite
another assignment by a different thread in cases in which an abstract machine
execution would not have encountered a data race. This includes implementations
of data member assignment that overwrite adjacent members in separate memory
locations. Reordering of atomic loads in cases in which the atomics in question
may alias is also generally precluded, since this may violate the coherence
rules. \exitnote

\pnum
\enternote Transformations that introduce a speculative read of a potentially
shared memory location may not preserve the semantics of the \Cpp program as
defined in this standard, since they potentially introduce a data race. However,
they are typically valid in the context of an optimizing compiler that targets a
specific machine with well-defined semantics for data races. They would be
invalid for a hypothetical machine that is not tolerant of races or provides
hardware race detection. \exitnote

\pnum
The implementation may assume that any thread will eventually do one of the 
following:

\begin{itemize}
\item 
terminate,

\item
make a call to a library I/O function,

\item
read or modify a volatile object, or

\item
perform a synchronization operation or an atomic operation.
\end{itemize}

\enternote This is intended to allow compiler transformations such as removal of
empty loops, even when termination cannot be proven. \exitnote

\pnum
An implementation should ensure that the last value (in modification order)
assigned by an atomic or synchronization operation will become visible to all
other threads in a finite period of time.%
\indextext{operation!atomic|)}%
\indextext{threads!multiple|)}

\rSec1[intro.ack]{Acknowledgments}

\pnum
The \Cpp  programming language as described in this International
Standard is based on the language as described in Chapter R (Reference
Manual) of Stroustrup: \doccite{The \Cpp  Programming Language} (second
edition, Addison-Wesley Publishing Company, ISBN 0-201-53992-6,
copyright \copyright 1991 AT\&T). That, in turn, is based on the C
programming language as described in Appendix A of Kernighan and
Ritchie: \doccite{The C Programming Language} (Prentice-Hall, 1978, ISBN
0-13-110163-3, copyright \copyright 1978 AT\&T).

\pnum
Portions of the library Clauses of this International Standard are based
on work by P.J. Plauger, which was published as \doccite{The Draft
Standard \Cpp  Library} (Prentice-Hall, ISBN 0-13-117003-1, copyright
\copyright 1995 P.J. Plauger).

\pnum
POSIX\textregistered\ is a registered trademark of the Institute of Electrical and
Electronic Engineers, Inc.

\pnum
All rights in these originals are reserved.
